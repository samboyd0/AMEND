% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RandomWalk.R
\name{RWR}
\alias{RWR}
\title{Random walk with restart (RWR) procedure}
\usage{
RWR(
  nadjM,
  setSeeds = NULL,
  restart = 0.75,
  heterogeneous = FALSE,
  multiplex = FALSE,
  net.weight,
  layer.weight
)
}
\arguments{
\item{nadjM}{Normalized adjacency matrix}

\item{setSeeds}{A named vector of seed values}

\item{restart}{Restart parameter}

\item{heterogeneous}{Logical. If TRUE, graph is considered heterogeneous (more than one distinct node type, e.g., proteins and metabolites), and node_type must be included as an argument or graph vertex attribute.}

\item{multiplex}{Logical. If true, graph is assumed to contain multiplex components.}

\item{net.weight}{A named vector, or NULL. Relative weight given to nodes of a component of graph, applied to seed vector in RWR. Only used when heterogeneous=TRUE.}

\item{layer.weight}{A named list of named vectors, or NULL. Relative weight given to nodes of a layer of a component of graph, applied to seed vector in RWR. List element names correspond to multiplex components, and vector names correspond to layers within a multiplex.}
}
\value{
matrix of diffusion scores from RWR
}
\description{
\code{RWR()} implements the RWR procedure. This simulates random walkers on a graph, with a certain probability of returning to the seeds nodes given by the restart parameter.
}
\details{
Seed values must be non-negative. For heterogeneous-multiplex graphs, the seed vector is a weighted concatenation of seed vectors from each component. Weights are given by \emph{net.weight} and must sum to one. These component-wise seed vectors are themselves weighted concatenations of seed vectors from each layer in the component, with each layer-wise seed vector independently normalized to sum to one. Weights are given by \emph{layer.weight} and must sum to one within each component. After the construction of the transition matrix and seed vector, RWR is implemented as usual through iterative matrix multiplication until convergence.
}
\examples{
library(igraph)

# Creating an adjacency matrix and graph
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
               1, 0, 1, 1, 1, 0, 0, 0,
               0, 1, 0, 0, 1, 1, 0, 0,
               0, 1, 0, 0, 0, 0, 1, 0,
               0, 1, 1, 0, 0, 0, 1, 1,
               0, 0, 1, 0, 0, 0, 0, 0,
               0, 0, 0, 1, 1, 0, 0, 0,
               0, 0, 0, 0, 1, 0, 0, 0), nrow = 8, dimnames = list(1:8, 1:8))
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
V(g)$name = 1:8

# Normalizing the adjacency matrix
adj_norm = Matrix::Matrix(adjm \%*\% diag(1 / degree(g)), dimnames = dimnames(adjm), sparse = TRUE)

# Creating a named vector of seed values
seeds = runif(8)
names(seeds) = 1:8

rwr = RWR(nadjM = adj_norm, setSeeds = seeds, restart = 0.8)

}
\seealso{
\code{\link[=run_AMEND]{run_AMEND()}}, \code{\link[=transition_matrix]{transition_matrix()}}, \code{\link[=create_integrated_graph]{create_integrated_graph()}}
}
