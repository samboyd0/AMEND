% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_integrated_graph.R
\name{create_integrated_graph}
\alias{create_integrated_graph}
\title{Create an integrated graph from a list of graph-like objects}
\usage{
create_integrated_graph(
  graph = NULL,
  adj_matrix = NULL,
  edge_list = NULL,
  data,
  node_type = NULL,
  brw.attr = NULL,
  FUN = NULL,
  FUN.params = NULL,
  heterogeneous = FALSE,
  multiplex = FALSE,
  lcc = FALSE
)
}
\arguments{
\item{graph, adj_matrix, edge_list}{A single graph like object in the form of an igraph, adjacency matrix, or edge list. Or, a named list containing multiple graph-like objects of the same type, to be merged. The merged graph must be connected. If a third column is provided in an edge list, these are taken as edge weights. Only one of graph, adj_matrix, or edge_list should be given, with priority given to graph, then adj_matrix, then edge_list. See 'Details' for correct naming conventions.}

\item{data}{A named list of named numeric vectors (list elements correspond to graph components), a named numeric vector, or a character string (denoting a vertex attribute of the input igraph object) containing the experimental data from which seed values for RWR will be derived according to \emph{FUN} and \emph{FUN.params} args. See 'Details' for correct naming conventions.}

\item{node_type}{A named list of character vectors (list elements correspond to graph components), a named character vector, a character string (denoting a vertex attribute of the input igraph object), or NULL. The list elements represent sets of nodes that belong to the corresponding components. The character vector contains \emph{component_layer} tags for the node name given in names of vector. If NULL and multiplex and/or heterogeneous, node labels must follow 'name|type_layer' naming scheme (e.g., MYC|gene_1). See 'Details' for correct naming conventions.}

\item{brw.attr}{A named list of named numeric vectors (list elements correspond to graph components), a named numeric vector, a character string (denoting a vertex attribute of the input igraph object), or NULL. Biased random walk vertex attribute values. Should be non-negative, with values greater (lesser) than 1 increasing (decreasing) transition probabilities to a node in RWR. If NULL, all nodes are given a value of 1. See 'Details' for biased random walk info.}

\item{FUN}{A function, named list of functions, named list of character strings, a single character string, or NULL. Function for transforming values in \emph{data} to derive seed values for RWR. Names correspond to graph components. Character strings should correspond to a default function: one of 'binary', 'shift_scale', 'p_value', or 'exp'. NULL means no transformation is done to values in \emph{data}. See 'Details' for descriptions of default functions.}

\item{FUN.params}{A named list of lists of named function arguments, a named list of named function arguments, or NULL. Function arguments to be passed to \emph{FUN}. Names should match names in \emph{FUN}.}

\item{heterogeneous}{Logical. If TRUE, graph is considered heterogeneous (more than one distinct node type, e.g., proteins and metabolites), and node_type must be included as an argument or graph vertex attribute.}

\item{multiplex}{Logical. If true, graph is assumed to contain multiplex components.}

\item{lcc}{Logical. If true, return Largest Connected Component}
}
\value{
an igraph of the integrated graph with vertex attributes 'seeds' and 'Z' computed from data, FUN, and FUN.params
}
\description{
Given a single graph-like object (igraph, adjacency matrix, or edge list) or a list of these, create a connected, integrated graph with seed values computed from \emph{data}, \emph{FUN}, and \emph{FUN.params}.
}
\details{
Heterogeneous graphs are graphs with more than one node type. We call these different subnetworks of node types \emph{components}. A multiplex graph has more than one edge or data type within a component, with the different subnetworks called \emph{layers}.

In order to be able to properly identify nodes in the network, there are a few naming conventions for both node labels and function arguments that must be followed.

If the input network is heterogeneous and a single object, node names must be appended with '|component', where 'component' is the name of the component and '|' is the delimiter (so node names can't contain '|'). If a list input, the list names correspond to the component and will be appended to node names in the integrated graph. The names of list elements corresponding to bipartite networks must include the relevant components separated by ';', e.g., 'protein;metabolite;drug' (so names of components also can't include ';').

If the input network is multiplex and a single object, node names must be appended with '|component_layer', where 'layer' is the name of the layer and '\verb{_}' is the delimiter (so component and layer names can't contain '_'). If a list input, the list names correspond either to the component \emph{and} layer, or if it only gives the component name and that component is multiplex, the node names must be appended with 'component_layer' to differentiate between layers. Bipartite connections between nodes of two multiplex components will be applied to all layers.

An effort was made to flexibly accept different network input objects. Just keep in mind that for heterogeneous/multiplex networks, the algorithm must have a way to identify a specific node within a specific component and layer using the '|' and '_' syntax described above.
}
\examples{
# example code
\dontrun{
#=== Monoplex-heterogeneous network ===#
# using a list of edge lists, with data as list input
# Create object for 'data' argument
data.list.input = vector("list", 2)
names(data.list.input) = c("prot", "meta")
for(i in seq_along(data.list.input)){
  uniq.names = extract_string(unique(c(edgelists[[i]][,1],
                                     edgelists[[i]][,2])), "\\\\|", 1)
  data.list.input[[i]] = rnorm(n = length(uniq.names), mean = 0, sd = 1)
  names(data.list.input[[i]]) = uniq.names
}

# Setting multiplex/heterogeneous parameters
net.weight = c(prot = 0.5, meta = 0.5)
jump.prob = c(prot = 0.7, meta = 0.3)

# FUN and FUN.params
FUN = list(prot = "shift_scale", meta = function(x, k) abs(x) * k)
FUN.params = list(prot = list(DOI = 1, w = 0.5), meta = list(k = 1.2))
g1 = create_integrated_graph(edge_list = edgelists, data = data.list.input,
                             node_type = NULL, brw.attr = NULL,
                             FUN = FUN, FUN.params = FUN.params,
                             heterogeneous = TRUE, multiplex = FALSE)

#=== Multiplex-heterogeneous network with list of graphs, data as vertex attribute ==#
# Create data vertex attributes, called 'scores'
v.attr.name = "scores"
node.types = c("prot_1", "prot_2", "prot_3", "meta")
for(i in seq_along(node.types)){
  # p-value
  igraph::vertex_attr(list.of.graphs[[node.types[i]]], v.attr.name) =
  runif(vcount(list.of.graphs[[node.types[i]]]))
}

# Setting multiplex/heterogeneous parameters
layer.weight = list(prot = rep(1/3, 3))
switch.layer.prob = list(prot = c(prot_1 = 0.5, prot_2 = 0.2, prot_3 = 0.8))
net.weight = c(prot = 0.5, meta = 0.5)
jump.prob = c(prot = 0.5, meta = 0.3)

g2 = create_integrated_graph(graph = list.of.graphs, data = "scores", node_type = NULL,
                             brw.attr = NULL, FUN = "p_value", FUN.params = NULL,
                             heterogeneous = TRUE, multiplex = TRUE)

#=== Multiplex-homogeneous network ===#
# list of adjacency matrices, data as list input
# Create a list of binary vectors
# (e.g., significantly up- or down-regulated genes)
data.list.input = vector("list", 3)
names(data.list.input) = c("prot_1", "prot_2", "prot_3")
for(i in seq_along(data.list.input)){
  data.list.input[[i]] = sample(x = c(0,1), size = nrow(list.of.adjmats[[i]]),
                                replace = T, prob = c(0.9, 0.1)) # binary
  names(data.list.input[[i]]) = rownames(list.of.adjmats[[i]])
}

# Setting multiplex/heterogeneous parameters
layer.weight = list(prot = c(prot_1 = 0.4, prot_2 = 0.3, prot_3 = 0.3))
switch.layer.prob = list(prot = c(prot_1 = 0.4, prot_2 = 0.5, prot_3 = 0.5))

g3 = create_integrated_graph(adj_matrix = list.of.adjmats, data = data.list.input,
                             node_type = NULL, brw.attr = NULL, FUN = "binary",
                             FUN.params = NULL, heterogeneous = FALSE, multiplex = TRUE)
}
}
\seealso{
\code{\link[=run_AMEND]{run_AMEND()}}, \code{\link[=list_input_checks]{list_input_checks()}}, \code{\link[=transition_matrix]{transition_matrix()}}, \code{\link[=RWR]{RWR()}}, \code{\link[=heinz]{heinz()}}, \code{\link[=get_subnetwork]{get_subnetwork()}}
}
