ncol = ncol(P0matrix), sparse = T)
for (j in 1:ncol(P0matrix)) {
P0 <- P0matrix[, j]
step <- 0
delta <- 1
PT <- P0
while (delta > stop_delta && step <= stop_step) {
PX <- (1 - r) * nadjM %*% PT + r * P0
delta <- sum(abs(PX - PT))
PT <- PX
step <- step + 1
}
PT[PT < 1e-06] <- 0
PTmatrix[, j] <- PT
}
}
PTmatrix <- sum2one(PTmatrix)
PTmatrix[PTmatrix < 1e-06] <- 0
PTmatrix <- Matrix::Matrix(PTmatrix, sparse = T)
rownames(PTmatrix) <- rownames(P0matrix)
colnames(PTmatrix) <- colnames(P0matrix)
invisible(PTmatrix)
}
library(dnet)
seeds = runif(8)
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
plot(g)
m = adjm %*% diag(degree(g))
adj_norm =  m %*% diag(1 / ifelse(colSums(m) == 0, 1, colSums(m)))
seeds = runif(8)
rwr = dRWR_alt(g, adj_norm, seeds, 0.8)
names(seeds) = 1:8
rwr = dRWR_alt(g, adj_norm, seeds, 0.8)
g
V(g)$name
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
V(g)$name = 1:8
m = adjm %*% diag(degree(g))
adj_norm =  m %*% diag(1 / ifelse(colSums(m) == 0, 1, colSums(m)))
seeds = runif(8)
names(seeds) = 1:8
rwr = dRWR_alt(g, adj_norm, seeds, 0.8)
rwr
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
#' adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
#' 0, 0, 1, 1, 1, 0, 0, 0,
#' 0, 0, 0, 0, 1, 1, 0, 0,
#' 0, 0, 0, 0, 0, 0, 1, 0,
#' 0, 0, 0, 0, 0, 0, 1, 1,
#' 0, 0, 0, 0, 0, 0, 0, 0,
#' 0, 0, 0, 0, 0, 0, 0, 0,
#' 0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
#' g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
#'
norm.adj <- function(g, adjM, norm = c("core", "degree", "weight")){
norm <- match.arg(norm)
ig <- g
if (norm == "core") {
adjE <- igraph::as_adjacency_matrix(ig, type = "both", sparse = FALSE)
core <- igraph::coreness(ig)
nadjM <- matrix(0, nrow = nrow(adjE), ncol = nrow(adjE))
for(j in 1:nrow(nadjM)){
cond <- adjE[,j] != 0
denom <- sum(core[cond])
nadjM[cond, j] <- core[cond]/denom
}
}
else if (norm == "degree") {
dg <- Matrix::Diagonal(x = igraph::degree(ig)^(-1))
nadjM <- adjM %*% dg
}
else if (norm == "weight") {
wt <- Matrix::Diagonal(x = Matrix::colSums(adjM)^(-1))
nadjM <- adjM %*% wt
}
else {
nadjM <- adjM
}
return(nadjM)
}
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
norm.adj(g, adjm)
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
V(g)$name = 1:8
m = adjm %*% diag(degree(g))
adj_norm =  m %*% diag(1 / ifelse(colSums(m) == 0, 1, colSums(m)))
seeds = runif(8)
names(seeds) = 1:8
search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3
search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3
)
search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3)
#' g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
#' V(g)$name = 1:8
#'
#' m = adjm %*% diag(degree(g))
#' adj_norm =  m %*% diag(1 / ifelse(colSums(m) == 0, 1, colSums(m)))
#' seeds = runif(8)
#' names(seeds) = 1:8
#'
#' search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3)
#'
smart.restart.grid.search <- function(g.min, g.max, n.1, levels = 3, ig, n.adj.M, seeds, filtering_rate){
# Create grid
get.r.grid<- function(best.g, g.min, g.max, p1, n){
p <- p1/(2^(n-1))
if(best.g == g.min){
new.grid <- best.g + p
}else if(best.g == g.max){
new.grid <- best.g - p
}else new.grid <- c(best.g - p, best.g + p)
return(new.grid)
}
p1 <- (g.max - g.min)/(n.1 - 1)
grid <- seq(g.max, g.min, by = -p1)
best.r <- numeric()
best.scores <- c(-Inf)
n <- 1
all_metrics = c()
repeat{
score_metrics <- matrix(nrow = length(grid), ncol = 3)
nets <- vector(mode = "list", length = length(grid))
for(i in seq_along(grid)){
# RWR
PTmatrix2 <- dRWR_alt(g = ig, nadjM = n.adj.M, setSeeds = seeds, restart = grid[i])
rwr_res <- as.vector(PTmatrix2)
# Scores for Maximum Scoring Subgraph Algorithm
rwr_score <- rwr_res - quantile(rwr_res, filtering_rate)
score <- rwr_score
names(score) <- V(ig)$name
nets[[i]] <- dNetFind_alt(ig, score)
n.v <- vcount(nets[[i]])
mZ <- sum(V(nets[[i]])$Z) / n.v
mCC = sum(core_cc(nets[[i]])) / n.v
score_metrics[i,] <- c(mCC, mZ, n.v)
}
score_metrics = score_metrics[which(score_metrics[,1] != 0),]
if(isTRUE(nrow(score_metrics) >= 1)){ # if score matrix isn't empty
max.id <- which.max(score_metrics[, 2] * score_metrics[, 1])
g.score <- score_metrics[max.id, 2] * score_metrics[max.id, 1]
all_metrics = c(all_metrics, score_metrics[,3])
}else if(n == 1){ # else if score matrix is empty on first level, break out of repeat loop
new.g = ig
n.v = vcount(new.g)
new.scores = c(sum(core_cc(new.g)) / n.v, sum(V(new.g)$Z) / n.v, n.v)
best.r = NA
break
}else g.score = -Inf # else if score matrix is empty NOT on first level
if(g.score > best.scores[ifelse(n == 1, 1, n-1)]){ # if best of current level is better than previous level
new.g <- nets[[max.id]]
new.scores <- score_metrics[max.id,]
best.scores[n] <- g.score
best.r[n] <- grid[max.id]
}else{ # else keep score from last level
best.scores[n] <- best.scores[n-1]
best.r[n] <- best.r[n-1]
}
if(n == levels) break
n <- n + 1
grid <- get.r.grid(best.r[n-1], g.min, g.max, p1, n)
}
return(list(new.g, new.scores, best.r[n]))
}
search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3)
#' @return subnetwork as an igraph object
#'
#' @examples
#' library(igraph)
#'
#' graph = sample_pa(n = 100, power = 1.2)
#' g_scores = rnorm(100)
#'
#' new_g = dNetFind_alt(g = graph, scores = g_scores)
#'
dNetFind_alt <- function (g, scores)
{
ig <- g
if (class(ig) != "igraph") {
stop("The function must apply to an 'igraph' object.\n")
}
if (is.null(V(ig)$name)) {
V(ig)$name <- as.character(V(ig))
}
if (is.null(names(scores))) {
stop("The function must require the names of the input scores.\n")
}
else if (any(is.na(names(scores)))) {
warning("Those scores with NA as names will be removed")
scores <- scores[!is.na(names(scores))]
}
V(ig)$score <- scores[V(ig)$name]
pos.nodes <- V(ig)[V(ig)$score > 0]$name
if (length(pos.nodes) == 0) {
warning("No positive nodes")
subgraph <- igraph::graph.empty(n = 0, directed = F)
}
else if (length(pos.nodes) == 1) {
subgraph <- dnet::dNetInduce(ig, pos.nodes, knn = 0, remove.loops = T,
largest.comp = T)
V(subgraph)$type <- "desired"
}
else {
pos.subgraph <- dnet::dNetInduce(ig, pos.nodes, knn = 0, remove.loops = T,
largest.comp = F)
conn.comp.graph <- igraph::decompose.graph(pos.subgraph)
score.comp <- unlist(lapply(lapply(conn.comp.graph,
function(x) as.numeric(V(x)$score)), sum))
ind_order <- order(score.comp, decreasing = T)
conn.comp.graph <- conn.comp.graph[ind_order]
score.comp <- score.comp[ind_order]
for (i in 1:length(conn.comp.graph)) {
conn.comp.graph[[i]]$score <- score.comp[i]
}
v.id <- seq(1, vcount(ig))
names(v.id) <- V(ig)$name
edgelist <- igraph::get.edgelist(ig, names = F)
edgelist1 <- edgelist[, 1]
edgelist2 <- edgelist[, 2]
#===#
ig.size <- vcount(ig)
for (i in 1:length(conn.comp.graph)) {
new.id <- ig.size + i
for (j in v.id[V(conn.comp.graph[[i]])$name]) {
edgelist1[edgelist1 == j] <- new.id
edgelist2[edgelist2 == j] <- new.id
}
}
#===#
new.ids <- seq(vcount(ig) + 1, vcount(ig) + length(conn.comp.graph))
new.names <- paste("cluster", seq(1:length(conn.comp.graph)),
sep = "")
names(new.ids) <- new.names
v.id <- c(v.id, new.ids)
v.name <- names(v.id)
names(v.name) <- v.id
new.edgelist <- cbind(v.name[as.character(edgelist1)],
v.name[as.character(edgelist2)])
mig <- igraph::graph.edgelist(new.edgelist, directed = F)
mig <- igraph::simplify(mig, remove.loops = T, remove.multiple = T)
node.score <- scores[V(mig)$name]
names(node.score) <- V(mig)$name
node.score.cluster <- sapply(conn.comp.graph, igraph::get.graph.attribute,
"score")
names(node.score.cluster) <- new.names
ind_cluster <- grep("cluster", names(node.score))
node.score[ind_cluster] <- node.score.cluster[names(node.score[ind_cluster])]
V(mig)$score <- node.score
score.degree <- 1/(igraph::degree(mig) + 1)
tmp_score <- V(mig)$score
tmp_score[tmp_score > 0] <- 0
V(mig)$score.degree <- score.degree * tmp_score
E(mig)$weight <- rep(0, length(E(mig)))
tmp_n1 <- igraph::get.edgelist(mig, names = F)[, 1]
tmp_n2 <- igraph::get.edgelist(mig, names = F)[, 2]
E(mig)$weight <- -(V(mig)[tmp_n1]$score.degree + V(mig)[tmp_n2]$score.degree)
if (!igraph::is.connected(mig)) {
decomp.graphs <- igraph::decompose.graph(mig)
sum.pos <- lapply(decomp.graphs, function(x) {
sum(node.score[names(which(node.score[V(x)$name] > 0))])
})
mig <- decomp.graphs[[which.max(sum.pos)]]
rm(decomp.graphs)
}
mst <- igraph::minimum.spanning.tree(mig, weights = E(mig)$weight)
mst.cluster.id <- grep("cluster", V(mst)$name)
names(mst.cluster.id) <- V(mst)[mst.cluster.id]$name
tmp <- unlist(strsplit(names(mst.cluster.id), "cluster"))
ttmp <- as.numeric(matrix(tmp, nrow = 2)[2, ])
mst.cluster.id <- mst.cluster.id[order(ttmp)]
all.ids <- c()
if (length(mst.cluster.id) == 1) {
neg.node.ids.2 = c()
}
else {
# Iteratively exclude all negative nodes of degree 1
loop = TRUE
while(loop){
neg_deg1 = V(mst)[igraph::degree(mst) == 1 & V(mst)$score < 0]
if(length(neg_deg1) == 0){
loop = FALSE
}else{
mst = igraph::induced_subgraph(mst, -neg_deg1)
}
}
sub.mig <- dnet::dNetInduce(mig, V(mst)$name, knn = 0, remove.loops = T, largest.comp = F)
neg.node.ids <- which(V(sub.mig)$score < 0)
for (i in neg.node.ids) {
tmp_nei <- igraph::neighbors(sub.mig, v = i)
tmp_nei_meta <- grep("cluster", V(sub.mig)[tmp_nei]$name)
V(sub.mig)[i]$clusters <- list(tmp_nei[tmp_nei_meta])
}
score.neg.nodes <- c()
for (i in neg.node.ids) {
if (!is.na(V(sub.mig)[i]$clusters[1])) {
borders <- c(i, V(sub.mig)[i]$clusters)
borders <- unlist(borders)
score.neg.nodes <- c(score.neg.nodes, sum(V(sub.mig)[borders]$score))
}
else {
score.neg.nodes <- c(score.neg.nodes, V(sub.mig)[i]$score)
}
}
neg.node.ids.2 <- neg.node.ids[score.neg.nodes > 0]
}
if (length(neg.node.ids.2) == 0) {
tmp <- unlist(strsplit(names(node.score.cluster)[which.max(node.score.cluster)], "cluster"))
ttmp <- as.numeric(matrix(tmp, nrow = 2)[2, ])
tmp_nodes <- unlist(lapply(conn.comp.graph, igraph::get.vertex.attribute, "name")[ttmp])
subgraph <- dnet::dNetInduce(ig, tmp_nodes, knn = 0, remove.loops = F,
largest.comp = T)
V(subgraph)$type <- "desired"
}
else {
subg <- dnet::dNetInduce(sub.mig, V(sub.mig)[neg.node.ids.2]$name,
knn = 0, remove.loops = T, largest.comp = T)
mst.subg <- igraph::minimum.spanning.tree(subg, E(subg)$weight)
getPathScore <- function(path, graph1, graph2) {
s1 <- V(graph1)[path]$score
tmp <- unique(unlist(V(graph1)[path]$clusters))
s2 <- V(graph2)[tmp]$score
sum(c(s1, s2))
}
max.score <- 0
best.path <- c()
for (i in 1:vcount(mst.subg)) {
path <- igraph::all_shortest_paths(mst.subg, from = V(mst.subg)[i])
path.score <- unlist(lapply(path$res, getPathScore,
graph1 = mst.subg, graph2 = sub.mig))
best.pos <- which.max(path.score)
if (path.score[[best.pos]] > max.score) {
best.path <- path$res[[best.pos]]
max.score <- path.score[[best.pos]]
}
}
if (length(best.path) != 1) {
cluster.list <- V(mst.subg)[best.path]$clusters
names.list <- as.character(1:length(cluster.list))
names(cluster.list) <- names.list
names(best.path) <- names.list
for (i in names.list) {
res <- lapply(cluster.list, intersect, cluster.list[[i]])
if (length(intersect(unlist(cluster.list[as.character(which(as.numeric(names.list) < as.numeric(i)))]),
unlist(cluster.list[as.character(which(as.numeric(names.list) > as.numeric(i)))]))) > 0) {
if (length(setdiff(res[[i]], unique(unlist(res[names(res) != i])))) == 0) {
cluster.list <- cluster.list[names(cluster.list) != i]
names.list <- names.list[names.list != i]
}
}
}
best.path <- best.path[names.list]
}
pos.cluster <- V(sub.mig)[unique(unlist(V(mst.subg)[best.path]$clusters))]$name
tmp <- unlist(strsplit(pos.cluster, "cluster"))
ttmp <- as.numeric(matrix(tmp, nrow = 2)[2, ])
tmp_meta_nodes <- unlist(lapply(conn.comp.graph,
igraph::get.vertex.attribute, "name")[ttmp])
tmp_border_nodes <- V(mst.subg)[best.path]$name
tmp_nodes <- c(tmp_border_nodes, tmp_meta_nodes)
subgraph <- dnet::dNetInduce(ig, tmp_nodes, knn = 0, remove.loops = F,
largest.comp = T)
type <- rep("desired", vcount(subgraph))
names(type) <- V(subgraph)$name
type[tmp_border_nodes[tmp_border_nodes %in% names(type)]] <- "linker"
V(subgraph)$type <- type
}
}
return(subgraph)
}
search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3)
#' @details text
#'
#' @param g (igraph object): input graph. must be connected
#'
#' @return vector of core-clustering coefficients for each node
#'
#' @examples
#' core_clust_coefs = core_cc(glut4_graph)
#' head(core_clust_coefs)
#'
core_cc = function(g){
if(!igraph::is_connected(g)) stop("Input graph must be connected")
w = numeric(vcount(g))
for(i in 1:vcount(g)){
nei = as.numeric(igraph::neighbors(g, i))
nborhood = igraph::induced_subgraph(g, c(nei, i))
cores = igraph::coreness(nborhood)
max_core = igraph::induced_subgraph(nborhood, which(cores == max(cores)))
w[i] = igraph::edge_density(max_core)
}
return(w)
}
search = smart.restart.grid.search(g.min = 0.1, g.max = 0.9, n.1 = 10, levels = 3, ig = g, n.adj.M = adj_norm, seeds = seeds, filtering_rate = 0.3)
search
library(devtools)
document()
check()
check()
check()
check()
check()
check()
check()
library(AMEND)
head(eci_scores)
library(igraph)
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1, 1,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
V(g)$name = 1:8
plot(g)
m = adjm %*% diag(degree(g))
m
adj_norm =  m %*% diag(1 / ifelse(colSums(m) == 0, 1, colSums(m)))
adj_norm
adjm
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
1, 0, 1, 1, 1, 0, 0, 0,
0, 1, 0, 0, 1, 1, 0, 0,
0, 1, 0, 0, 0, 0, 1, 0,
0, 1, 1, 0, 0, 0, 1, 1,
0, 0, 1, 0, 0, 0, 0, 0,
0, 0, 0, 1, 0, 0, 0, 0,
0, 0, 0, 1, 0, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
V(g)$name = 1:8
plot(g)
adjm = matrix(c(0, 1, 0, 0, 0, 0, 0, 0,
1, 0, 1, 1, 1, 0, 0, 0,
0, 1, 0, 0, 1, 1, 0, 0,
0, 1, 0, 0, 0, 0, 1, 0,
0, 1, 1, 0, 0, 0, 1, 1,
0, 0, 1, 0, 0, 0, 0, 0,
0, 0, 0, 1, 1, 0, 0, 0,
0, 0, 0, 0, 1, 0, 0, 0), nrow = 8)
g = graph_from_adjacency_matrix(adjm, mode = 'undirected')
V(g)$name = 1:8
plot(g)
m = adjm %*% diag(degree(g))
m
adj_norm =  m %*% diag(1 / ifelse(colSums(m) == 0, 1, colSums(m)))
adj_norm
adjm
m = adjm %*% diag(1 / degree(g))
m
adj_norm = adjm %*% Matrix::Diagonal(x = igraph::degree(g)^(-1))
adj_norm
head(E(glut4_graph)$weight)
set.seed(1.444222)
runif(1)
set.seed(1.444223)
runif(1)
set.seed(1.444)
runif(1)
set.seed(1)
runif(1)
set.seed(2)
runif(1)
?set.seed
set.seed(1.999)
runif(1)
set.seed(1)
runif(1)
set.seed(2.999)
runif(1)
set.seed(2)
runif(1)
